ATIVIDADE 01 ‚Äì PADR√ÉO DE PROJETO GOF - CRIACIONAL
 
1 ‚Äì INTRODU√á√ÉO A PADR√ïES DE PROJETO: 

QUEST√ÉO-1.1: O que √© um padr√£o de projeto? Explique o conceito, objetivos e benef√≠cios de se  utilizar padr√µes no desenvolvimento de software. 

Padr√£o de projeto s√£o modelos que auxiliam na elabora√ß√£o de um projeto, seja no seu c√≥digo, documenta√ß√£o, etc.  Tem como objetivo tornar sua elabora√ß√£o mais f√°cil e organizada, e seus benef√≠cios s√£o a reutiliza√ß√£o e aplica√ß√£o para diversos projetos, al√©m de melhorarem a documenta√ß√£o e manuten√ß√£o do sistema, o que torna eles bem acess√≠veis. Eles ajudam a identificar equ√≠vocos e armadilhas e aumentam a produtividade, trazendo experi√™ncia para os desenvolvedores.

QUEST√ÉO-1.2: Explique as quatro partes fundamentais que comp√µem um padr√£o de projeto segundo o Cat√°logo GoF. 

Nome do padr√£o (descreve o problema e suas solu√ß√µes), problema (como aplicar um padr√£o e incluir detalhes necess√°rios), solu√ß√£o (estrutura do padr√£o e apresenta de forma gen√©rica quando resolver o problema) e consequ√™ncias (vantagens e desvantagens de aplicar um padr√£o no projeto).

QUEST√ÉO-1.3: Por que padr√µes de projeto podem melhorar a manuten√ß√£o e documenta√ß√£o de  sistemas orientados a objetos? 

Os padr√µes de projeto tornam mais f√°cil a compreens√£o e elabora√ß√£o de documenta√ß√£o, c√≥digos, componentes, etc, e podem ser reutilizados, o que facilita muito para os desenvolvedores, aplicando seus conhecimentos pr√©vios e experi√™ncias no seu desenvolvimento.

QUEST√ÉO-1.4: Quais s√£o os principais riscos ou cr√≠ticas associados ao uso indiscriminado de  padr√µes de projeto? 

	Os principais riscos e cr√≠ticas est√£o associados √† sistematiza√ß√£o de abordagens amplamente utilizadas, unifica√ß√£o e implementa√ß√£o desses projetos sem adapta√ß√£o, assim como traz dificuldade para os novatos, que podem tentar aplic√°-los a todos os projetos, prezando pela simplicidade.

2 ‚Äì PADR√ÉO GOP ‚Äì CRIACIONAL ‚Äì FACTORY METHOD 

QUEST√ÉO-2.1: Defina o padr√£o Factory Method, seu objetivo e quando √© indicado utiliz√°-lo. 

	O padr√£o Factory Method (m√©todo f√°brica, construtor virtual), √© um padr√£o criacional que fornece uma interface para criar objetos em uma superclasse, mas permite que essas subclasses alterem os tipos de objetos que ser√£o criados. Seu objetivo √© definir uma interface de cria√ß√£o de objeto, com permiss√£o de inst√¢ncia para subclasses, e ele √© indicado para ser utilizado quando uma classe n√£o pode antecipar a classe dos objetos que deve criar, ou quando a classe deseja que suas subclasses especifiquem o objeto que ser√° criado.

QUEST√ÉO-2.2: Qual a diferen√ßa entre criar objetos diretamente com new e usar Factory Method?
 
	Com o padr√£o Factory Method, os objetos s√£o criados com o operador new, o que faz com que voc√™ possa sobrescrever o m√©todo f√°brica em uma subclasse e alterar a classe de produtos que est√£o sendo criados pelo m√©todo.

QUEST√ÉO-2.3: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Factory Method: Voc√™ est√° desenvolvendo uma aplica√ß√£o de log√≠stica que deve  permitir entrega por caminh√£o, navio ou drone. Implemente uma solu√ß√£o usando o padr√£o Factory  Method, criando uma interface Transporte e subclasses concretas para cada modal. Crie uma classe Log√≠stica com m√©todo de f√°brica. Utilize a linguagem de POO desejada.  

// interface transporte
class Transporte {
    entregar() {
        throw new Error("M√©todo 'entregar()' deve ser implementado.");
    }
}

// subclasses concretas
class Caminhao extends Transporte {
    entregar() {
        console.log("Entrega feita por caminh√£o.");
    }
}

class Navio extends Transporte {
    entregar() {
        console.log("Entrega feita por navio.");
    }
}

class Drone extends Transporte {
    entregar() {
        console.log("Entrega feita por drone.");
    }
}

// classe log√≠stica 
class Logistica {
    criarTransporte() {
        throw new Error("M√©todo 'criarTransporte()' deve ser sobrescrito.");
    }

    planejarEntrega() {
        const transporte = this.criarTransporte();
        transporte.entregar();
    }
}

// subclasses de Logistica 
class LogisticaRodoviaria extends Logistica {
    criarTransporte() {
        return new Caminhao();
    }
}

class LogisticaMaritima extends Logistica {
    criarTransporte() {
        return new Navio();
    }
}

class LogisticaAerea extends Logistica {
    criarTransporte() {
        return new Drone();
    }
}

// teste
const rodoviaria = new LogisticaRodoviaria();
rodoviaria.planejarEntrega(); 

const maritima = new LogisticaMaritima();
maritima.planejarEntrega(); 

const aerea = new LogisticaAerea();
aerea.planejarEntrega();  


QUEST√ÉO-2.4: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Factory Method: Um sistema educacional precisa permitir a cria√ß√£o de diferentes  tipos de provas (objetiva, dissertativa, pr√°tica). O aluno deve criar uma interface Prova, implementar  as variantes concretas e utilizar Factory Method para instanciar dinamicamente o tipo correto. 

// interface prova
class Prova {
    realizar() {
        throw new Error("O m√©todo 'realizar()' deve ser implementado.");
    }
}

// provas concretas
class ProvaObjetiva extends Prova {
    realizar() {
        console.log("Aplicando prova objetiva: m√∫ltipla escolha.");
    }
}

class ProvaDissertativa extends Prova {
    realizar() {
        console.log("Aplicando prova dissertativa: reda√ß√£o.");
    }
}

class ProvaPratica extends Prova {
    realizar() {
        console.log("Aplicando prova pr√°tica: atividade pr√°tica em laborat√≥rio.");
    }
}

// criador base
class SistemaEducacional {
    criarProva() {
        throw new Error("O m√©todo 'criarProva()' deve ser sobrescrito.");
    }

    aplicarProva() {
        const prova = this.criarProva();
        prova.realizar();
    }
}

// criadores concretos
class SistemaObjetivo extends SistemaEducacional {
    criarProva() {
        return new ProvaObjetiva( );
    }
}

class SistemaDissertativo extends SistemaEducacional {
    criarProva() {
        return new ProvaDissertativa( );
    }
}

class SistemaPratico extends SistemaEducacional {
    criarProva() {
        return new ProvaPratica();
    }
}

// teste
const prova1 = new SistemaObjetivo();
prova1.aplicarProva();

const prova2 = new SistemaDissertativo();
prova2.aplicarProva(); 

const prova3 = new SistemaPratico();
prova3.aplicarProva(); 


QUEST√ÉO-2.5: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Factory Method: Uma empresa de software cria interfaces de usu√°rio para Windows,  Mac e Linux. Modele uma estrutura usando Factory Method para criar os elementos da interface de  forma independente da plataforma. 

// interface base do bot√£o
class Botao {
    render() {
        throw new Error("O m√©todo 'render( )' deve ser implementado.");
    }
}

// bot√µes espec√≠ficos para cada sistema operacional
class BotaoWindows extends Botao {
    render() {
        console.log("Renderizando bot√£o estilo Windows");
    }
}

class BotaoMac extends Botao {
    render() {
        console.log("Renderizando bot√£o estilo Mac");
    }
}

class BotaoLinux extends Botao {
    render() {
        console.log("Renderizando bot√£o estilo Linux");
    }
}

// criador base: janela
class Janela {
    criarBotao() {
        throw new Error("O m√©todo 'criarBotao()' deve ser sobrescrito.");
    }

    desenharJanela( ) {
        const botao = this.criarBotao();
        console.log("Desenhando a janela.");
        botao.render();
    }
}

// criadores concretos para cada sistema operacional
class JanelaWindows extends Janela {
    criarBotao() {
        return new BotaoWindows();
    }
}

class JanelaMac extends Janela {
    criarBotao() {
        return new BotaoMac();
    }
}

class JanelaLinux extends Janela {
    criarBotao() {
        return new BotaoLinux();
    }
}

// teste
const appWin = new JanelaWindows();
appWin.desenharJanela(); 

const appMac = new JanelaMac();
appMac.desenharJanela();

const appLinux = new JanelaLinux();
appLinux.desenharJanela(); 


QUEST√ÉO-2.6: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Factory Method: Uma aplica√ß√£o de agendamento de servi√ßos permite agendar  consultas, reparos e entregas. O aluno deve implementar um Criador abstrato com um m√©todo  factory, e classes concretas para cada tipo de servi√ßo.

// interface base
class Servico {
    executar() {
        throw new Error("O m√©todo 'executar()' deve ser implementado.");
    }
}

// tipos de servi√ßo
class Consulta extends Servico {
    executar() {
        console.log("Agendando consulta m√©dica.");
    }
}

class Reparo extends Servico {
    executar() {
        console.log("Agendando reparo t√©cnico.");
    }
}

class Entrega extends Servico {
    executar() {
        console.log("Agendando entrega de produto.");
    }
}

// criador abstrato
class Agendamento {
    criarServico() {
        throw new Error("O m√©todo 'criarServico()' deve ser sobrescrito.");
    }

    agendar() {
        const servico = this.criarServico();
        servico.executar();
    }
}

// criadores concretos
class AgendamentoConsulta extends Agendamento {
    criarServico() {
        return new Consulta();
    }
}

class AgendamentoReparo extends Agendamento {
    criarServico ) {
        return new Reparo();
    }
}

class AgendamentoEntrega extends Agendamento {
    criarServico() {
        return new Entrega();
    }
}

// teste
const ag1 = new AgendamentoConsulta();
ag1.agendar(); 
const ag2 = new AgendamentoReparo();
ag2.agendar(); 
const ag3 = new AgendamentoEntrega();
ag3.agendar(); 






3 ‚Äì PADR√ÉO GOP ‚Äì CRIACIONAL ‚Äì ABSTRACT FACTORY: 

QUEST√ÉO-3.1: Explique o padr√£o Abstract Factory, destacando suas principais caracter√≠sticas e  diferen√ßas em rela√ß√£o ao Factory Method. 

	O padr√£o Abstract Factory  √© uma forma de criar conjuntos de objetos que est√£o relacionados sem precisar dizer exatamente qual √© a classe de cada um deles. O Factory Method cria uma interface que define um √∫nico tipo de objeto, mas permite que as subclasses decidam qual classe concreta ser√° instanciada. J√° o Abstract Factory vai al√©m e define uma interface para criar fam√≠lias inteiras de objetos relacionados.

QUEST√ÉO-3.2: Em que situa√ß√µes o uso de Abstract Factory √© mais indicado? 

	√â √∫til quando o c√≥digo precisa trabalhar com v√°rias fam√≠lias de produtos relacionados, mas n√£o quer depender de classes concretas desses produtos, permitindo futura escalabilidade. √â recomendado implementar ele quando uma classe lida com m√∫ltiplos tipos de produtos, para manter a responsabilidade de cada classe bem definida.

QUEST√ÉO-3.3: Como esse padr√£o promove a compatibilidade entre objetos de uma mesma fam√≠lia? 

Fornece uma interface para a cria√ß√£o de objetos de cada classe, prevenindo a cria√ß√£o de uma variante errada de um produto que n√£o coincide com produtos j√° criados pela aplica√ß√£o.

QUEST√ÉO-3.3: Quais os benef√≠cios de separar a cria√ß√£o de fam√≠lias de objetos em f√°bricas distintas? 

	Os benef√≠cios s√£o isolamento da l√≥gica de cria√ß√£o, facilidade de substitui√ß√£o de fam√≠lias inteiras de objetos, garantia de compatibilidade de objetos, maior flexibilidade e escalabilidade.

QUEST√ÉO-3.4: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Abstract Method: Um jogo permite criar personagens her√≥icos e malvados, cada um com armas e habilidades diferentes. Modele o sistema usando Abstract Factory para garantir que todos os elementos criados perten√ßam √† mesma fam√≠lia tem√°tica. 

// interfaces base
class Personagem {
    apresentar() { throw new Error("Implementar apresentar()"); }
}
class Arma {
    usar() { throw new Error("Implementar usar()"); }
}
class Habilidade {
    ativar() { throw new Error("Implementar ativar()"); }
}

// vers√µes heroicas
class GuerreiroHeroico extends Personagem {
    apresentar() { console.log("Guerreiro da luz."); }
}
class EspadaHeroica extends Arma {
    usar() { console.log("Golpeando com a espada sagrada."); }
}
class CuraHeroica extends Habilidade {
    ativar() { console.log("Usando habilidade de cura divina."); }
}

// vers√µes malvadas
class GuerreiroMalvado extends Personagem {
    apresentar() { console.log("Guerreiro das sombras."); }
}
class MachadoMalvado extends Arma {
    usar() { console.log("Cortando com o machado sombrio."); }
}
class VenenoMalvado extends Habilidade {
    ativar() { console.log("Liberando veneno trai√ßoeiro."); }
}

// f√°brica abstrata
class FabricaPersonagem {
    criarPersonagem() { throw new Error("Implementar criarPersonagem"); }
    criarArma() { throw new Error("Implementar criarArma"); }
    criarHabilidade() { throw new Error("Implementar criarHabilidade"); }
}

// f√°brica heroica
class FabricaHeroica extends FabricaPersonagem {
    criarPersonagem() { return new GuerreiroHeroico(); }
    criarArma() { return new EspadaHeroica(); }
    criarHabilidade() { return new CuraHeroica(); }
}

// f√°brica malvada
class FabricaMalvada extends FabricaPersonagem {
    criarPersonagem() { return new GuerreiroMalvado(); }
    criarArma() { return new MachadoMalvado(); }
    criarHabilidade() { return new VenenoMalvado(); }
}

// cliente (jogo)
class Jogo {
    constructor(fabrica) {
        this.personagem = fabrica.criarPersonagem();
        this.arma = fabrica.criarArma();
        this.habilidade = fabrica.criarHabilidade();
    }

    iniciar() {
        this.personagem.apresentar();
        this.arma.usar();
        this.habilidade.ativar();
    }
}

// teste
console.log("Jogo Heroico:");
const jogoHeroico = new Jogo(new FabricaHeroica());
jogoHeroico.iniciar();

console.log("Jogo Malvado:");
const jogoMalvado = new Jogo(new FabricaMalvada());
jogoMalvado.iniciar();

QUEST√ÉO-3.5: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Abstract Method: Um e-commerce possui duas linhas de produtos: eletr√¥nicos e  moda. Cada tipo possui f√°bricas diferentes. Modele a aplica√ß√£o usando Abstract Factory, com  f√°bricas concretas e interfaces de produto. 

// interfaces de produto
class ProdutoEletronico {
    exibir() {
        throw new Error("exibir() deve ser implementado.");
    }
}

class ProdutoModa {
    exibir() {
        throw new Error("exibir() deve ser implementado.");
    }
}

// produtos eletr√¥nicos
class Smartphone extends ProdutoEletronico {
    exibir() {
        console.log("Produto Eletr√¥nico: Smartphone.");
    }
}

class Notebook extends ProdutoEletronico {
    exibir() {
        console.log("Produto Eletr√¥nico: Notebook.");
    }
}

// produtos de Moda
class Camisa extends ProdutoModa {
    exibir() {
        console.log("Produto de Moda: Camisa.");
    }
}

class Jaqueta extends ProdutoModa {
    exibir() {
        console.log("Produto de Moda: Jaqueta.");
    }
}

// f√°brica abstrata
class FabricaProdutos {
    criarProdutoEletronico() {
        throw new Error("criarProdutoEletronico() precisa ser implementado.");
    }
    criarProdutoModa() {
        throw new Error("criarProdutoModa() precisa ser implementado.");
    }
}

// f√°brica concreta: eletr√¥nicos
class FabricaEletronico extends FabricaProdutos {
    criarProdutoEletronico() {
        return new Smartphone();
    }
    criarProdutoModa() {
        return new Camisa();
    }
}

// f√°brica concreta: moda
class FabricaModa extends FabricaProdutos {
    criarProdutoEletronico() {
        return new Notebook();
    }
    criarProdutoModa() {
        return new Jaqueta();
    }
}

// cliente
class LojaVirtual {
    constructor(fabrica) {
        this.produtoEletronico = fabrica.criarProdutoEletronico();
        this.produtoModa = fabrica.criarProdutoModa();
    }

    mostrarVitrine() {
        this.produtoEletronico.exibir();
        this.produtoModa.exibir();
    }
}

// teste
console.log("Vitrine Eletr√¥nica:");
const loja1 = new LojaVirtual(new FabricaEletronico());
loja1.mostrarVitrine();

console.log("Vitrine de Moda:");
const loja2 = new LojaVirtual(new FabricaModa());
loja2.mostrarVitrine();

QUEST√ÉO-3.6: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Abstract Method: Voc√™ est√° desenvolvendo uma ferramenta multiplataforma. Crie um  exemplo usando Abstract Factory para construir a interface de usu√°rio (bot√µes, menus, janelas) de  forma consistente para cada SO. 

// interfaces dos componentes
class Botao {
    render() { throw new Error("render() deve ser implementado."); }
}

class Menu {
    render() { throw new Error("render() deve ser implementado."); }
}

class Janela {
    render() { throw new Error("render() deve ser implementado."); }
}

// componentes para windows
class BotaoWindows extends Botao {
    render() { console.log("ü™ü Bot√£o estilo Windows renderizado."); }
}

class MenuWindows extends Menu {
    render() { console.log("ü™ü Menu estilo Windows renderizado."); }
}

class JanelaWindows extends Janela {
    render() { console.log("ü™ü Janela estilo Windows renderizada."); }
}

// componentes para mac
class BotaoMac extends Botao {
    render() { console.log("Bot√£o estilo Mac renderizado."); }
}

class MenuMac extends Menu {
    render() { console.log("Menu estilo Mac renderizado."); }
}

class JanelaMac extends Janela {
    render() { console.log("Janela estilo Mac renderizada."); }
}

// f√°brica abstrata
class UIFactory {
    criarBotao() { throw new Error("criarBotao() deve ser implementado."); }
    criarMenu() { throw new Error("criarMenu() deve ser implementado."); }
    criarJanela() { throw new Error("criarJanela() deve ser implementado."); }
}

// f√°brica Windows
class FabricaWindows extends UIFactory {
    criarBotao() { return new BotaoWindows(); }
    criarMenu() { return new MenuWindows(); }
    criarJanela() { return new JanelaWindows(); }
}

// f√°brica Mac
class FabricaMac extends UIFactory {
    criarBotao() { return new BotaoMac(); }
    criarMenu() { return new MenuMac(); }
    criarJanela() { return new JanelaMac(); }
}

// cliente
class Aplicativo {
    constructor(factory) {
        this.botao = factory.criarBotao();
        this.menu = factory.criarMenu();
        this.janela = factory.criarJanela();
    }

    renderizarInterface() {
        console.log("Renderizando interface:");
        this.botao.render();
        this.menu.render();
        this.janela.render();
    }
}

// teste
console.log("Interface Windows:");
const appWin = new Aplicativo(new FabricaWindows());
appWin.renderizarInterface();

console.log("Interface Mac:");
const appMac = new Aplicativo(new FabricaMac());
appMac.renderizarInterface();

QUEST√ÉO-3.7: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Abstract Method: Um sistema banc√°rio internacional precisa adaptar-se para criar  componentes diferentes em cada pa√≠s (menu, idioma, layout). Modele com Abstract Factory para  garantir coer√™ncia e manuten√ß√£o. 

// interfaces dos componentes
class Menu {
    render() { throw new Error("Implementar render()"); }
}

class Idioma {
    traduzir(texto) { throw new Error("Implementar traduzir()"); }
}

class Layout {
    aplicar() { throw new Error("Implementar aplicar()"); }
}

// componentes para brasil
class MenuBrasil extends Menu {
    render() { console.log("Menu em estilo brasileiro: Conta, Transfer√™ncia, Pix"); }
}

class IdiomaBrasil extends Idioma {
    traduzir(texto) {
        console.log(`Traduzindo '${texto}' para portugu√™s.`);
    }
}

class LayoutBrasil extends Layout {
    aplicar() { console.log("Layout responsivo com cores verde e amarela."); }
}

// componentes para jap√£o
class MenuJapao extends Menu {
    render() { console.log("„É°„Éã„É•„Éº: „Ç¢„Ç´„Ç¶„É≥„Éà, ÈÄÅÈáë, „ÅäÁü•„Çâ„Åõ"); }
}

class IdiomaJapao extends Idioma {
    traduzir(texto) {
        console.log(` ÁøªË®≥‰∏≠ '${texto}' „Åã„ÇâÊó•Êú¨Ë™û„Å∏„ÄÇ`);
    }
}

class LayoutJapao extends Layout {
    aplicar() { console.log("Layout minimalista com cores s√≥brias."); }
}

// f√°brica abstrata
class FabricaBancaria {
    criarMenu() { throw new Error("Implementar criarMenu"); }
    criarIdioma() { throw new Error("Implementar criarIdioma"); }
    criarLayout() { throw new Error("Implementar criarLayout"); }
}

// f√°brica brasil
class FabricaBrasil extends FabricaBancaria {
    criarMenu() { return new MenuBrasil(); }
    criarIdioma() { return new IdiomaBrasil(); }
    criarLayout() { return new LayoutBrasil(); }
}

// f√°brica jap√£o
class FabricaJapao extends FabricaBancaria {
    criarMenu() { return new MenuJapao(); }
    criarIdioma() { return new IdiomaJapao(); }
    criarLayout() { return new LayoutJapao(); }
}

// cliente
class SistemaBancario {
    constructor(fabrica) {
        this.menu = fabrica.criarMenu();
        this.idioma = fabrica.criarIdioma();
        this.layout = fabrica.criarLayout();
    }

    iniciar() {
        console.log("Inicializando sistema banc√°rio internacional...");
        this.menu.render();
        this.idioma.traduzir("Bem-vindo");
        this.layout.aplicar();
    }
}

// teste
console.log("Sistema do Brasil:");

QUEST√ÉO-3.8: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Abstract Method: Um simulador de ve√≠culos precisa criar diferentes componentes  (motor, roda, freio) conforme o tipo de carro (esportivo ou popular). Modele com Abstract Factory com  classes f√°brica especializadas. 

// interfaces dos componentes
class Motor {
    ligar() { throw new Error("Implementar ligar()"); }
}

class Roda {
    girar() { throw new Error("Implementar girar()"); }
}

class Freio {
    frear() { throw new Error("Implementar frear()"); }
}

// componentes para carro esportivo
class MotorEsportivo extends Motor {
    ligar() { console.log("Motor esportivo ligado."); }
}

class RodaEsportiva extends Roda {
    girar() { console.log("Rodas esportivas girando em alta velocidade."); }
}

class FreioEsportivo extends Freio {
    frear() { console.log("Freios esportivos acionados com precis√£o."); }
}

// componentes para carro popular
class MotorPopular extends Motor {
    ligar() { console.log("Motor popular ligado."); }
}

class RodaPopular extends Roda {
    girar() { console.log("Rodas populares girando suavemente."); }
}

class FreioPopular extends Freio {
    frear() { console.log("Freios comuns acionados."); }
}

// f√°brica abstrata
class FabricaVeiculo {
    criarMotor() { throw new Error("criarMotor() deve ser implementado."); }
    criarRoda() { throw new Error("criarRoda() deve ser implementado."); }
    criarFreio() { throw new Error("criarFreio() deve ser implementado."); }
}

// f√°brica de carro esportivo
class FabricaEsportivo extends FabricaVeiculo {
    criarMotor() { return new MotorEsportivo(); }
    criarRoda() { return new RodaEsportiva(); }
    criarFreio() { return new FreioEsportivo(); }
}

// f√°brica de carro popular
class FabricaPopular extends FabricaVeiculo {
    criarMotor() { return new MotorPopular(); }
    criarRoda() { return new RodaPopular(); }
    criarFreio() { return new FreioPopular(); }
}

// cliente
class SimuladorVeiculo {
    constructor(fabrica) {
        this.motor = fabrica.criarMotor();
        this.roda = fabrica.criarRoda();
        this.freio = fabrica.criarFreio();
    }

    simular() {
        console.log("Iniciando simula√ß√£o do ve√≠culo.");
        this.motor.ligar();
        this.roda.girar();
        this.freio.frear();
    }
}

// teste
console.log("Simulador de carro popular:");
const popular = new SimuladorVeiculo(new FabricaPopular());
popular.simular();

console.log("Simulador de carro esportivo:");
const esportivo = new SimuladorVeiculo(new FabricaEsportivo());
esportivo.simular();

4 - PADR√ÉO GOP ‚Äì CRIACIONAL ‚Äì BUILDER 

QUEST√ÉO-4.1: O que √© o padr√£o Builder? Em que cen√°rios ele √© mais indicado? 

O padr√£o Builder √© utilizado para construir objetos passo a passo, simplificando a cria√ß√£o de objetos complexos que requerem muitos par√¢metros, indicado em cen√°rios onde o sistema cria objetos complexos.  

QUEST√ÉO-4.2: Quais s√£o os principais elementos do padr√£o Builder e seus pap√©is? 

	Interface (declara etapas de constru√ß√£o do produto), builders concretos (prov√©m diferentes implementa√ß√µes das etapas de constru√ß√£o. Produzem elementos que n√£o seguem a interface comum), elementos (s√£o objetos resultantes, constru√≠dos por diferentes builders e n√£o precisam necessariamente pertencer a mesma interface), classe (define a ordem na qual as etapas s√£o chamadas) e por fim o m√©todo (associa um dos objetos com a classe).

QUEST√ÉO-4.3: Diferencie o Builder de um construtor comum. 

Dentro de um construtor s√≥ √© poss√≠vel passar todos os elementos de uma vez, no Builder √© poss√≠vel passar todos os elementos de uma vez s√≥.

QUEST√ÉO-4.4: Como o Builder facilita a cria√ß√£o de objetos imut√°veis e complexos?

	Ele oferece a simplifica√ß√£o do c√≥digo de inicializa√ß√£o, possibilitando a reutiliza√ß√£o de c√≥digos e cria√ß√£o de objetos complexos com mais facilidade. Al√©m disso, facilita a modifica√ß√£o de atributos de um objeto, modificando no builder correspondente sem afetar o c√≥digo do cliente ou os outros builders.

QUEST√ÉO-4.5: D√™ um exemplo de aplica√ß√£o do padr√£o Builder em um sistema real. 

	Ele pode ser aplicado em um sistema de formul√°rios, onde um formul√°rio pode ter muitos campos e op√ß√µes, mas o usu√°rio pode precisar definir apenas alguns deles. O padr√£o Builder pode ser usado para elaborar os objetos do formul√°rio com diferentes combina√ß√µes de campos e op√ß√µes.

QUEST√ÉO-4.6: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Builder: Um sistema de pizzaria permite que o cliente monte sua pr√≥pria pizza com diferentes ingredientes. Modele a solu√ß√£o usando Builder, separando cada etapa da montagem em  m√©todos do builder. 

// pizza
class Pizza {
    constructor() {
        this.massa = "";
        this.molho = "";
        this.queijo = "";
        this.toppings = [];
    }

    exibir() {
        console.log("Sua pizza est√° pronta:");
        console.log(`Massa: ${this.massa}`);
        console.log(`Molho: ${this.molho}`);
        console.log(`Queijo: ${this.queijo}`);
        console.log(`Ingredientes: ${this.toppings.join(", ")}`);
    }
}

// builder
class PizzaBuilder {
    constructor() {
        this.pizza = new Pizza();
    }

    escolherMassa(tipo) {
        this.pizza.massa = tipo;
        return this;
    }

    adicionarMolho(tipo) {
        this.pizza.molho = tipo;
        return this;
    }

    adicionarQueijo(tipo) {
        this.pizza.queijo = tipo;
        return this;
    }

    adicionarIngrediente(ingrediente) {
        this.pizza.toppings.push(ingrediente);
        return this;
    }

    montar() {
        return this.pizza;
    }
}

// receitas padr√£o
class Cozinha {
    static prepararPizzaCalabresa() {
        return new PizzaBuilder()
            .escolherMassa("Tradicional")
            .adicionarMolho("Tomate")
            .adicionarQueijo("Mussarela")
            .adicionarIngrediente("Calabresa")
            .adicionarIngrediente("Cebola")
            .montar();
    }

    static prepararPizzaVegana() {
        return new PizzaBuilder()
            .escolherMassa("Integral")
            .adicionarMolho("Tomate")
            .adicionarQueijo("Queijo vegetal")
            .adicionarIngrediente("Br√≥colis")
            .adicionarIngrediente("Piment√£o")
            .montar();
    }
}

// teste

console.log("Pizza personalizada:");
const minhaPizza = new PizzaBuilder()
    .escolherMassa("Pan")
    .adicionarMolho("Barbecue")
    .adicionarQueijo("Cheddar")
    .adicionarIngrediente("Frango")
    .adicionarIngrediente("Bacon")
    .montar();
minhaPizza.exibir();

console.log("Pizza Calabresa:");
const calabresa = Cozinha.prepararPizzaCalabresa();
calabresa.exibir();

console.log("Pizza Vegana:");
const vegana = Cozinha.prepararPizzaVegana();
vegana.exibir();

QUEST√ÉO-4.7: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Builder: Um sistema de relat√≥rios permite montar documentos com capa, sum√°rio,  conte√∫do e gr√°ficos. Modele a constru√ß√£o desses relat√≥rios passo a passo usando um Diretor e  Builder. 

// produto final
class Relatorio {
    constructor() {
        this.capa = "";
        this.sumario = "";
        this.conteudo = "";
        this.graficos = "";
    }

    exibir() {
        console.log("Relat√≥rio Montado:");
        console.log(`Capa: ${this.capa}`);
        console.log(`Sum√°rio: ${this.sumario}`);
        console.log(`Conte√∫do: ${this.conteudo}`);
        console.log(`Gr√°ficos: ${this.graficos}`);
    }
}

// builder
class RelatorioBuilder {
    constructor() {
        this.relatorio = new Relatorio();
    }

    adicionarCapa(titulo) {
        this.relatorio.capa = titulo;
        return this;
    }

    adicionarSumario(itens) {
        this.relatorio.sumario = itens.join(", ");
        return this;
    }

    adicionarConteudo(texto) {
        this.relatorio.conteudo = texto;
        return this;
    }

    adicionarGraficos(descricao) {
        this.relatorio.graficos = descricao;
        return this;
    }

    construir() {
        return this.relatorio;
    }
}

// relat√≥rios padr√£o
class DiretorRelatorio {
    constructor(builder) {
        this.builder = builder;
    }

    construirRelatorioFinanceiro() {
        return this.builder
            .adicionarCapa("Relat√≥rio Financeiro 2025")
            .adicionarSumario(["Receita", "Despesas", "Lucro"])
            .adicionarConteudo("Este relat√≥rio apresenta os dados financeiros do ano.")
            .adicionarGraficos("Gr√°fico de barras e pizza com comparativos trimestrais.")
            .construir();
    }

    construirRelatorioProjetos() {
        return this.builder
            .adicionarCapa("Relat√≥rio de Projetos em Andamento")
            .adicionarSumario(["Projetos", "Equipes", "Cronograma"])
            .adicionarConteudo("An√°lise detalhada dos projetos ativos.")
            .adicionarGraficos("Gantt, barra de progresso e KPIs visuais.")
            .construir();
    }
}

// teste

// relat√≥rio feito com diretor
const builder1 = new RelatorioBuilder();
const diretor = new DiretorRelatorio(builder1);
const relatorioFinanceiro = diretor.construirRelatorioFinanceiro();
relatorioFinanceiro.exibir();

console.log("\n");

// relat√≥rio personalizado, feito manualmente
const builder2 = new RelatorioBuilder();
const relatorioCustom = builder2
    .adicionarCapa("Relat√≥rio de Pesquisa de Mercado")
    .adicionarSumario(["Introdu√ß√£o", "Metodologia", "Resultados"])
    .adicionarConteudo("O estudo de mercado revelou tend√™ncias de consumo relevantes.")
    .adicionarGraficos("Gr√°ficos de linha e nuvem de palavras.")
    .construir();

relatorioCustom.exibir();

QUEST√ÉO-4.8: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Builder: Em uma aplica√ß√£o de educa√ß√£o, o aluno monta sua grade hor√°ria semanal  com disciplinas, hor√°rios e salas. Use Builder para permitir uma constru√ß√£o flex√≠vel e personaliz√°vel  da grade. 

// GradeHoraria
class GradeHoraria {
    constructor() {
        this.disciplinas = [];
    }

    exibir() {
        console.log("Grade Hor√°ria Semanal:");
        this.disciplinas.forEach((disciplina, index) => {
            console.log(
                `${index + 1}. ${disciplina.nome} ‚Äî ${disciplina.horario} ‚Äî Sala ${disciplina.sala}`
            );
        });
    }
}

// builder
class GradeBuilder {
    constructor() {
        this.grade = new GradeHoraria();
    }

    adicionarDisciplina(nome, horario, sala) {
        this.grade.disciplinas.push({
            nome,
            horario,
            sala,
        });
        return this;
    }

    construir() {
        return this.grade;
    }
}

// teste

const minhaGrade = new GradeBuilder()
    .adicionarDisciplina("Matem√°tica", "Segunda 08h‚Äì10h", "101")
    .adicionarDisciplina("Portugu√™s", "Ter√ßa 10h‚Äì12h", "102")
    .adicionarDisciplina("Programa√ß√£o", "Quarta 14h‚Äì16h", "Lab 01")
    .adicionarDisciplina("Hist√≥ria", "Sexta 09h‚Äì11h", "103")
    .construir();

minhaGrade.exibir();

QUEST√ÉO-4.9: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Builder: Um sistema de cadastro de estudantes permite definir nome, curso,  endere√ßo, e-mail, celular, respons√°veis. Implemente o Builder para esse caso, permitindo  preenchimento opcional dos dados. 

// estudante
class Estudante {
    constructor(builder) {
        this.nome = builder.nome;
        this.curso = builder.curso;
        this.endereco = builder.endereco;
        this.email = builder.email;
        this.celular = builder.celular;
        this.responsaveis = builder.responsaveis;
    }

    exibir() {
        console.log("Estudante Cadastrado:");
        console.log(`Nome: ${this.nome}`);
        console.log(`Curso: ${this.curso || "N√£o informado"}`);
        console.log(`Endere√ßo: ${this.endereco || "N√£o informado"}`);
        console.log(`Email: ${this.email || "N√£o informado"}`);
        console.log(`Celular: ${this.celular || "N√£o informado"}`);
        console.log(`Respons√°veis: ${this.responsaveis?.join(", ") || "N√£o informado"}`);
    }
}

// builder
class EstudanteBuilder {
    constructor(nome) {
        if (!nome) throw new Error("O nome √© obrigat√≥rio!");
        this.nome = nome;
    }

    setCurso(curso) {
        this.curso = curso;
        return this;
    }

    setEndereco(endereco) {
        this.endereco = endereco;
        return this;
    }

    setEmail(email) {
        this.email = email;
        return this;
    }

    setCelular(celular) {
        this.celular = celular;
        return this;
    }

    setResponsaveis(lista) {
        this.responsaveis = lista;
        return this;
    }

    construir() {
        return new Estudante(this);
    }
}

// teste
const estudanteCompleto = new EstudanteBuilder("Natali")
    .setCurso("DSM")
    .setEndereco("Rua Tiradentes, 1837")
    .setEmail("natalidau@gmail.com")
    .setCelular("11 91234-5678")
    .setResponsaveis(["Lafayete", "Katia"])
    .construir();

estudanteCompleto.exibir();

console.log("\n");

const estudanteSimples = new EstudanteBuilder("Katia")
    .setCurso("Pedagogia")
    .construir();

estudanteSimples.exibir();

QUEST√ÉO-4.10: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Builder: Um menu de aplicativo permite adicionar t√≠tulo, √≠cones, atalhos e submenu.  Modele a estrutura usando Builder, permitindo composi√ß√£o fluente. 

// menu
class MenuApp {
    constructor() {
        this.titulo = "";
        this.icones = [];
        this.atalhos = [];
        this.submenus = [];
    }

    exibir(indent = 0) {
        const prefix = " ".repeat(indent);
        console.log(`${prefix} Menu: ${this.titulo}`);
        if (this.icones.length) console.log(`${prefix} √çcones: ${this.icones.join(", ")}`);
        if (this.atalhos.length) console.log(`${prefix} Atalhos: ${this.atalhos.join(", ")}`);
        if (this.submenus.length) {
            console.log(`${prefix} Submenus:`);
            this.submenus.forEach(sub => sub.exibir(indent + 4));
        }
    }
}

// builder
class MenuBuilder {
    constructor() {
        this.menu = new MenuApp();
    }

    setTitulo(titulo) {
        this.menu.titulo = titulo;
        return this;
    }

    adicionarIcone(icone) {
        this.menu.icones.push(icone);
        return this;
    }

    adicionarAtalho(atalho) {
        this.menu.atalhos.push(atalho);
        return this;
    }

    adicionarSubmenu(submenuBuilder) {
        const submenu = submenuBuilder.construir();
        this.menu.submenus.push(submenu);
        return this;
    }

    construir() {
        return this.menu;
    }
}

// teste

const menuAjuda = new MenuBuilder()
    .setTitulo("Ajuda")
    .adicionarIcone("‚ùì")
    .adicionarAtalho("F1");

menuPrincipal.exibir();

5 ‚Äì PADR√ÉO GOP ‚Äì CRIACIONAL ‚Äì PROTOTYPE 

QUEST√ÉO-5.1: Defina o padr√£o Prototype e seu prop√≥sito no desenvolvimento de software.

	O padr√£o de design Prototype ajuda a criar c√≥pias de objetos sem precisar mudar o c√≥digo de suas classes originais . Ele permite que crie novos objetos a partir de modelos existentes de maneira f√°cil e r√°pida. Seu prop√≥sito √© utilizar m√©todos de clonagem para copiar o objeto e modificar apenas o que for necess√°rio, sem criar algo do zero.

 QUEST√ÉO-5.2: Quando √© indicado usar o padr√£o Prototype? 

	O padr√£o Prototype √© indicado para ser utilizado quando precisa criar muitas c√≥pias de objetos que possuem uma estrutura complexa e que seria dif√≠cil de instanciar manualmente, al√©m de tamb√©m ser √∫til quando voc√™ deseja criar novos objetos com pequenas varia√ß√µes a partir de um modelo existente.

QUEST√ÉO-5.3: Como o Prototype contribui para a efici√™ncia na cria√ß√£o de objetos? 

	Ele contribui permitindo que voc√™ crie novos objetos a partir de modelos existentes sem precisar mudar o c√≥digo original desses modelos, assim criando uma classe ‚Äúprot√≥tipo‚Äù que possui um m√©todo para clonar objetos, assim sendo necess√°rio apenas utilizar o m√©todo de clonagem para copiar o objeto e modificar apenas o que for necess√°rio no novo objeto.

QUEST√ÉO-5.4: Explique como implementar Prototype em uma linguagem orientada a objetos. 

	Cria-se uma classe que representa um objeto que se pretende clonar, outra que √© respons√°vel por gerenciar as inst√¢ncias da classe clon√°vel. Ao adicionar um novo objeto, cria-se uma nova inst√¢ncia da primeira classe e armazena-se no dicion√°rio de objeto, usando o id como chave. Ao solicitar o id, chama-se o m√©todo clone() de inst√¢ncia, que faz uma c√≥pia superficial do objeto e retorna uma nova inst√¢ncia id√™ntica √† original.

QUEST√ÉO-5.5: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Prototype: Uma editora digital utiliza documentos como contratos, cartas e relat√≥rios.  Modele o sistema com Prototype, criando uma classe Documento com m√©todo clone(), e classes  derivadas. 

// classe base 
class Documento {
    constructor(titulo, conteudo) {
        this.titulo = titulo;
        this.conteudo = conteudo;
    }

    clone() {
        return new this.constructor(this.titulo, this.conteudo);
    }

    exibir() {
        console.log(`Tipo: ${this.constructor.name}`);
        console.log(`T√≠tulo: ${this.titulo}`);
        console.log(`Conte√∫do: ${this.conteudo}`);
        console.log("---");
    }
}

// subclasses concretas
class Contrato extends Documento {}
class Carta extends Documento {}
class Relatorio extends Documento {}

// testes
const contratoOriginal = new Contrato("Contrato de Presta√ß√£o de Servi√ßos", "Este contrato estabelece os termos...");

contratoOriginal.exibir();

QUEST√ÉO-5.6: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Prototype:Uma pizzaria utiliza prot√≥tipos de pizzas para clonagem r√°pida dos pedidos.  Modele com Prototype e permita altera√ß√µes no clone (ex: ingredientes extras).

// classe base
class Pizza {
    constructor(nome, ingredientes = [], borda = "normal") {
        this.nome = nome;
        this.ingredientes = ingredientes;
        this.borda = borda;
    }

    clone() {
        return new Pizza(
            this.nome,
            [...this.ingredientes],
            this.borda
        );
    }

    exibir() {
        console.log(`Pizza: ${this.nome}`);
        console.log(`   Ingredientes: ${this.ingredientes.join(", ")}`);
        console.log(`   Borda: ${this.borda}`);
        console.log("---");
    }
}

// testes
const pizzaCalabresa = new Pizza("Calabresa", ["calabresa", "cebola", "mussarela"]);
const pizzaFrango = new Pizza("Frango com Catupiry", ["frango", "catupiry", "or√©gano"]);
const pizzaMarguerita = new Pizza("Marguerita", ["tomate", "manjeric√£o", "mussarela"]);

const pedido1 = pizzaCalabresa.clone();
pedido1.ingredientes.push("azeitona");
pedido1.borda = "recheada de cheddar";

const pedido2 = pizzaFrango.clone();
pedido2.ingredientes = pedido2.ingredientes.filter(i => i !== "catupiry");
pedido2.ingredientes.push("creme de milho");

const pedido3 = pizzaMarguerita.clone(); 

console.log(‚ÄúPedido original (prot√≥tipos):");
pizzaCalabresa.exibir();
pizzaFranco = pizzaFrango.exibir();
pizzaMarguerita.exibir();

console.log("Pedidos clonados:");
pedido1.exibir(); // Calabresa + azeitona + borda recheada
pedido2.exibir(); // Frango sem catupiry + creme de milho
pedido3.exibir(); // Marguerita padr√£o

QUEST√ÉO-5.7: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Prototype:Um sistema CAD permite clonar formas gr√°ficas com pequenas altera√ß√µes.  Modele com Prototype e implemente formas como classes concretas que implementam o m√©todo  clone(). 

// classe base
class Forma {
    constructor(x, y, cor) {
        this.x = x;
        this.y = y;
        this.cor = cor;
    }

    clone() {
        return new this.constructor(this.x, this.y, this.cor);
    }

    desenhar() {
        console.log(`Forma: ${this.constructor.name}`);
        console.log(`Posi√ß√£o: (${this.x}, ${this.y})`);
        console.log(`Cor: ${this.cor}`);
    }
}

// formas concretas
class Circulo extends Forma {
    constructor(x, y, cor, raio) {
        super(x, y, cor);
        this.raio = raio;
    }

    clone() {
        const clone = new Circulo(this.x, this.y, this.cor, this.raio);
        return clone;
    }

    desenhar() {
        super.desenhar();
        console.log(`   Raio: ${this.raio}`);
        console.log("---");
    }
}

class Retangulo extends Forma {
    constructor(x, y, cor, largura, altura) {
        super(x, y, cor);
        this.largura = largura;
        this.altura = altura;
    }

    clone() {
        return new Retangulo(this.x, this.y, this.cor, this.largura, this.altura);
    }

    desenhar() {
        super.desenhar();
        console.log(`   Largura: ${this.largura}, Altura: ${this.altura}`);
        console.log("---");
    }
}

// testes
const circuloOriginal = new Circulo(10, 20, "vermelho", 15);
const retanguloOriginal = new Retangulo(30, 40, "azul", 50, 20);

const circuloClone = circuloOriginal.clone();
circuloClone.x += 10;
circuloClone.cor = "laranja";

const retanguloClone = retanguloOriginal.clone();
retanguloClone.altura = 40;
retanguloClone.y += 5;

console.log("Formas originais:");
circuloOriginal.desenhar();
retanguloOriginal.desenhar();

console.log("Clones modificados:");
circuloClone.desenhar();
retanguloClone.desenhar();

QUEST√ÉO-5.8: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Prototype: Uma aplica√ß√£o de RH precisa clonar perfis de cargos com pequenas  varia√ß√µes de requisitos. Modele usando Prototype com base em modelos de cargo. 

// classe cargo
class Cargo {
    constructor(titulo, salario, requisitos = []) {
        this.titulo = titulo;
        this.salario = salario;
        this.requisitos = requisitos;
    }

    clone() {
            return new Cargo(
            this.titulo,
            this.salario,
            [...this.requisitos]
        );
    }

    exibir() {
        console.log(`Cargo: ${this.titulo}`);
        console.log(`Sal√°rio: R$ ${this.salario.toFixed(2)}`);
        console.log(`Requisitos: ${this.requisitos.join(", ")}`);
        console.log("---");
    }
}

// testes
const devJunior = new Cargo("Desenvolvedor J√∫nior", 3000, [
    "JavaScript b√°sico",
    "HTML e CSS",
    "Git"
]);

const devSenior = new Cargo("Desenvolvedor S√™nior", 8000, [
    "JavaScript avan√ßado",
    "Node.js",
    "Arquitetura de software",
    "Lideran√ßa de equipe"
]);

const devJuniorMobile = devJunior.clone();
devJuniorMobile.titulo = "Dev J√∫nior - Mobile";
devJuniorMobile.requisitos.push("React Native");

const devSeniorFullstack = devSenior.clone();
devSeniorFullstack.titulo = "Dev S√™nior Fullstack";
devSeniorFullstack.requisitos.push("React", "MongoDB");

console.log("Cargos Originais:");
devJunior.exibir();
devSenior.exibir();

console.log("Cargos Clonados e Personalizados:");
devJuniorMobile.exibir();
devSeniorFullstack.exibir();

QUEST√ÉO-5.9: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Prototype: Um sistema de agendamento de aulas usa modelos de hor√°rios que s√£o  clonados e ajustados. Modele com Prototype criando uma classe Hor√°rio com suporte a clonagem. 

// classe base
class Horario {
    constructor(disciplina, professor, dia, hora, sala) {
        this.disciplina = disciplina;
        this.professor = professor;
        this.dia = dia;
        this.hora = hora;
        this.sala = sala;
    }

    clone() {
        return new Horario(
            this.disciplina,
            this.professor,
            this.dia,
            this.hora,
            this.sala
        );
    }

    exibir() {
        console.log(`${this.disciplina} ‚Äî Prof. ${this.professor}`);
        console.log(`Dia: ${this.dia}, Hora: ${this.hora}, Sala: ${this.sala}`);
        console.log("---");
    }
}

// testes
const modeloMatematica = new Horario(
    "Matem√°tica",
    "Natali",
    "Segunda-feira",
    "08:00",
    "Sala 101"
);

const turmaB = modeloMatematica.clone();
turmaB.dia = "Ter√ßa-feira";
turmaB.sala = "Sala 102";

const turmaC = modeloMatematica.clone();
turmaC.hora = "10:00";
turmaC.professor = "Bruno";
turmaC.sala = "Sala 201";

console.log("Modelo base:");
modeloMatematica.exibir();

console.log("Hor√°rios clonados:");
turmaB.exibir();
turmaC.exibir();

6 ‚Äì PADR√ÉO GOP ‚Äì CRIACIONAL ‚Äì SINGLETON 

QUEST√ÉO-6.1: O que √© o padr√£o Singleton e qual sua finalidade? 

O padr√£o Singleton garante que apenas uma inst√¢ncia de classe seja criada e acessada de forma global, o que garante que sempre ser√° trabalhada a mesma inst√¢ncia, independente de quantas vezes ela seja instanciada.

QUEST√ÉO-6.2: Quais problemas esse padr√£o pode causar em sistemas grandes? 

	O padr√£o singleton pode causar dificuldade de manter e testar conforme o crescimento do sistema.

QUEST√ÉO-6.3: Quando √© apropriado usar Singleton? 

Quando for necess√°rio acessar recursos compartilhados com o banco de dados ou extens√£o com internet, ou quando for necess√°rio controlar o acesso a um objeto de forma centralizada, assim como quando houver apenas uma inst√¢ncia de classe, e para economizar recursos de mem√≥ria e processamento, al√©m de evitar conflito entre inst√¢ncias.

QUEST√ÉO-6.4: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Singleton: Implemente um gerenciador de configura√ß√µes de sistema que garanta  apenas uma inst√¢ncia acess√≠vel globalmente. Use uma classe com m√©todo est√°tico getInstance(). 

class ConfiguracoesSistema {
    constructor() {
        if (ConfiguracoesSistema.instancia) {
            return ConfiguracoesSistema.instancia;
        }

        this.configs = {};
        ConfiguracoesSistema.instancia = this;
    }

    static getInstance() {
        if (!ConfiguracoesSistema.instancia) {
            ConfiguracoesSistema.instancia = new ConfiguracoesSistema();
        }
        return ConfiguracoesSistema.instancia;
    }

    setConfig(chave, valor) {
        this.configs[chave] = valor;
    }

    getConfig(chave) {
        return this.configs[chave];
    }

    exibirConfigs() {
        console.log("Configura√ß√µes Atuais:", this.configs);
    }
}

// testes
const sistema1 = ConfiguracoesSistema.getInstance();
sistema1.setConfig("modoEscuro", true);
sistema1.setConfig("idioma", "pt-BR");

const sistema2 = ConfiguracoesSistema.getInstance();
sistema2.setConfig("notificacoes", false);

console.log("Mesma inst√¢ncia?", sistema1 === sistema2); // true

sistema1.exibirConfigs();

QUEST√ÉO-6.5: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Singleton:Um sistema de log deve garantir que todas as partes da aplica√ß√£o escrevam  no mesmo arquivo de log. Modele com Singleton usando um m√©todo est√°tico para acesso global ao  logger. 

class Logger {
    constructor() {
        if (Logger.instancia) {
            return Logger.instancia;
        }

        this.logs = [];
        Logger.instancia = this;
    }

    static getInstance() {
        if (!Logger.instancia) {
            Logger.instancia = new Logger();
        }
        return Logger.instancia;
    }

    log(mensagem) {
        const timestamp = new Date().toISOString();
        this.logs.push(`[${timestamp}] ${mensagem}`);
    }

    exibirLogs() {
        console.log("LOG DO SISTEMA:");
        this.logs.forEach(log => console.log(log));
    }
}

// teste
const logger1 = Logger.getInstance();
logger1.log("Sistema iniciado");
logger1.log("Usu√°rio autenticado");

const logger2 = Logger.getInstance();
logger2.log("Requisi√ß√£o ao servidor enviada");
logger2.log("Resposta recebida com sucesso");

console.log("Mesma inst√¢ncia?", logger1 === logger2); // true

logger1.exibirLogs();

QUEST√ÉO-6.6: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Singleton: Uma aplica√ß√£o de vendas online deve garantir um √∫nico carrinho de  compras por usu√°rio. Modele com Singleton garantindo consist√™ncia nas opera√ß√µes do carrinho. 

class CarrinhoCompras {
    constructor() {
        if (CarrinhoCompras.instancia) {
            return CarrinhoCompras.instancia;
        }

        this.itens = [];
        CarrinhoCompras.instancia = this;
    }

    static getInstance() {
        if (!CarrinhoCompras.instancia) {
            CarrinhoCompras.instancia = new CarrinhoCompras();
        }
        return CarrinhoCompras.instancia;
    }

    adicionarItem(nome, preco) {
        this.itens.push({ nome, preco });
        console.log(`Item adicionado: ${nome} (R$ ${preco.toFixed(2)})`);
    }

    removerItem(nome) {
        this.itens = this.itens.filter(item => item.nome !== nome);
        console.log(`Item removido: ${nome}`);
    }

    listarItens() {
        console.log("Itens no carrinho:");
        this.itens.forEach(item => {
            console.log(`- ${item.nome}: R$ ${item.preco.toFixed(2)}`);
        });
    }

    totalizar() {
        const total = this.itens.reduce((acc, item) => acc + item.preco, 0);
        console.log(`Total: R$ ${total.toFixed(2)}`);
        return total;
    }
}

// teste
const carrinho1 = CarrinhoCompras.getInstance();
carrinho1.adicionarItem("Fone Bluetooth", 199.90);
carrinho1.adicionarItem("Mouse Gamer", 149.90);

const carrinho2 = CarrinhoCompras.getInstance();
carrinho2.adicionarItem("Camiseta Oversized", 89.90);
carrinho2.removerItem("Mouse Gamer");

console.log("Mesmo carrinho?", carrinho1 === carrinho2); // true

carrinho1.listarItens();
carrinho1.totalizar();

QUEST√ÉO-6.7: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Singleton: Um cache de dados compartilhado por diversos m√≥dulos precisa ser  centralizado. Modele com Singleton para manter o cache acess√≠vel de forma segura. 

class CacheDados {
    constructor() {
        if (CacheDados.instancia) {
            return CacheDados.instancia;
        }

        this.cache = {};
        CacheDados.instancia = this;
    }

    static getInstance() {
        if (!CacheDados.instancia) {
            CacheDados.instancia = new CacheDados();
        }
        return CacheDados.instancia;
    }

    set(chave, valor) {
        this.cache[chave] = valor;
        console.log(`Cache atualizado: ${chave} ‚Üí ${valor}`);
    }

    get(chave) {
        return this.cache[chave] ?? null;
    }

    exibir() {
        console.log("Conte√∫do do Cache:");
        console.log(this.cache);
    }
}

// teste
const cacheA = CacheDados.getInstance();
cacheA.set("usuario", "Natali");
cacheA.set("tema", "escuro");

const cacheB = CacheDados.getInstance();
cacheB.set("token", "abc123");

const cacheC = CacheDados.getInstance();
console.log("Usu√°rio atual:", cacheC.get("usuario"));
console.log("Tema atual:", cacheC.get("tema"));
console.log("Token:", cacheC.get("token"));

console.log("Mesma inst√¢ncia?", cacheA === cacheB && cacheB === cacheC); // true

cacheC.exibir();

QUEST√ÉO-6.8: Utilizando sua linguagem de POO desejada (recomenda-se JavaScript), resolva com o Padr√£o GoF - Singleton:Um sistema de licen√ßas de software deve manter apenas uma inst√¢ncia do  verificador de licen√ßa. Modele com Singleton assegurando controle √∫nico de valida√ß√£o.

class ValidadorLicenca {
    constructor() {
        if (ValidadorLicenca.instancia) {
            return ValidadorLicenca.instancia;
        }

        this.status = "Nenhuma licen√ßa verificada ainda.";
        ValidadorLicenca.instancia = this;
    }

    static getInstance() {
        if (!ValidadorLicenca.instancia) {
            ValidadorLicenca.instancia = new ValidadorLicenca();
        }
        return ValidadorLicenca.instancia;
    }

    validar(licenca) {
        if (licenca === "LICENCA-VALIDA-1234") {
            this.status = "Licen√ßa v√°lida.";
        } else {
            this.status = "Licen√ßa inv√°lida.";
        }
    }

    exibirStatus() {
        console.log("Status da Licen√ßa:", this.status);
    }
}

// teste
const verificador1 = ValidadorLicenca.getInstance();
verificador1.validar("LICENCA-INVALIDA-0000");
verificador1.exibirStatus();

const verificador2 = ValidadorLicenca.getInstance();
verificador2.validar("LICENCA-VALIDA-1234");
verificador2.exibirStatus();

console.log("Mesma inst√¢ncia?", verificador1 === verificador2);
